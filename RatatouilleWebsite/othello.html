<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Othello</title>

    <script type="text/javascript">
    </script>
    <style type="text/css">
      canvas { border: 1px solid black; }
    </style>
</head>

<body onload="draw();">



  <script type="text/javascript">

	var boardView = document.getElementById('OthelloBoard');
	var squareSize = 50;
	var boardSize = 400;
	var pieceRadius = 20;
	var serialBoardString = null;
	var nextMove = "white";
	var boardColour = 'rgb(0, 200, 0)';
	var counterMoveTimeout;


	document.getElementById("DebugText").innerHTML = "Script loaded" ;

	/*=============================================================================*/
	/* Setup requestAnimationFrame
	/*=============================================================================*/
	var setupRAF = function(){
	  var lastTime = 0;
	  var vendors = ['ms', 'moz', 'webkit', 'o'];
	  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x){
		window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
		window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
	  };

	  if(!window.requestAnimationFrame){
		window.requestAnimationFrame = function(callback, element){
		  var currTime = new Date().getTime();
		  var timeToCall = Math.max(0, 16 - (currTime - lastTime));
		  var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
		  lastTime = currTime + timeToCall;
		  return id;
		};
	  };

	  if (!window.cancelAnimationFrame){
		window.cancelAnimationFrame = function(id){
		  clearTimeout(id);
		};
	  };
	};

	setupRAF();

	function changeNextMove() {
		if (nextMove == "white")
			nextMove = "black"
		else
			nextMove = "white"
	}

	function draw() {
	  document.getElementById("DebugText").innerHTML = "Draw";

	  if (window.boardView.getContext) {
		  var ctx = boardView.getContext('2d');

		  ctx.beginPath();
		  ctx.fillStyle = boardColour;
		  ctx.fillRect(0, 0, window.boardSize, window.boardSize);

		  //draw row and column lines
		  for (x=0; x<=window.boardSize; x+=window.squareSize) {
			  ctx.moveTo(x, 0);
			  ctx.lineTo(x, window.boardSize);

			  ctx.moveTo(0, x);
			  ctx.lineTo(window.boardSize, x);
		  }
		  ctx.stroke();
	  }

	  if (serialBoardString != null) {
		  document.getElementById("DebugText").innerHTML = "Draw will draw pieces " + serialBoardString;
		  drawPieces(serialBoardString);
	  }
	}

	// get and draw the initial pieces
	var xhttp = new XMLHttpRequest();
	xhttp.onreadystatechange = function() {
	  document.getElementById("DebugText").innerHTML = "onreadystatechange " + this.readyState + " " + this.status ;

	  if (this.readyState == 4 && this.status == 200) {
		 // Typical action to be performed when the document is ready:
		 serialBoardString = xhttp.responseText;
		 document.getElementById("DebugText").innerHTML = "Drawing initial board " + serialBoardString;
		 drawPieces(serialBoardString);
	  }
	};
	xhttp.open("GET", "../newBoard", true);
	xhttp.send();


	function squareCenter(x,y) {
	  return [x * window.squareSize + window.squareSize/2,
			  y * window.squareSize + window.squareSize/2]

	}

	function drawPiece(x,y,black) {
	  	var ctx = boardView.getContext('2d');
		ctx.beginPath();
		center = squareCenter(x, y);
		ctx.arc(center[0], center[1], pieceRadius, 0, 2 * Math.PI);
		if (black) {
			ctx.fillStyle = 'rgb(0,0,0)';
		}
		else {
			ctx.fillStyle = 'rgb(255,255,255)';
		}
		ctx.fill();
	}

	function drawPieces(s) {
	  var x = 0;
	  var y = 0;
	  var blackCount = 0;
	  var whiteCount = 0;

	  for (var i=0; i < s.length; i++) {

		  switch (s.charAt(i)) {
		  case 'b':
			  drawPiece(x, y, true);
			  x++;
			  blackCount++;
			  break;

		  case 'w':
			  drawPiece(x, y, false);
			  x++;
			  whiteCount++;
			  break;

		  case '$':
			  x = 0;
			  y++;
			  break;

		  case '-':
			  x++;
			  break;
		  }
	  }

	  // display the counts
	  document.getElementById("BlackCount").innerHTML = blackCount;
	  document.getElementById("WhiteCount").innerHTML = whiteCount;
	}

	/*=============================================================================*/
	/* Animate flips
	/*=============================================================================*/

	function animateFlips(flips, colour) {

		function animateSingleFlip(flip) {
		    var startTime = 0

			var aLoop = function(timeStamp) {

				if (startTime == 0) {
					startTime = timeStamp
				}

				var duration = 500
				if (timeStamp - startTime < duration) {
					requestAnimationFrame(aLoop, boardView)
				}

				if (colour == "black") {
					fromColour = 'rgb(255,255,255)';
					toColour = 'rgb(0,0,0)';
				}
				else {
					fromColour = 'rgb(0,0,0)';
					toColour = 'rgb(255,255,255)';
				}

				ticks = timeStamp - startTime;

				var fractionComplete = Math.min(1, ticks / duration)
				var center = squareCenter(flip[0], flip[1])
				var ctx = boardView.getContext('2d');

				// erase old piece
				ctx.beginPath();
				ctx.arc(center[0], center[1], pieceRadius+2, 0, 2 * Math.PI);
				ctx.fillStyle = boardColour;
				ctx.fill();
				ctx.closePath();

				// draw flipping piece
				ctx.beginPath();

				// shrinking old piece
				if (fractionComplete < 0.5) {
				  	ctx.fillStyle = fromColour;
					animatedRadius = pieceRadius * (1 - fractionComplete*2)
				}
				else { // expand new piece
				  	ctx.fillStyle = toColour;
					animatedRadius = pieceRadius * (fractionComplete - 0.5) * 2

				}
				ctx.ellipse(center[0], center[1], pieceRadius, animatedRadius, 0, 0, 2 * Math.PI)
				ctx.fill();
				ctx.closePath();
			};
			aLoop(0);
		};

		flips.forEach(animateSingleFlip);
	}

	function counterMove() {
		xhttp = new XMLHttpRequest();
		url = "../bestMove?" +
		"newSquareState=" + nextMove + "&" +
		"boardState=" + serialBoardString;

		xhttp.open("GET", url, true);
		xhttp.onreadystatechange =	function() {
			document.getElementById("DebugText").innerHTML = "onreadystatechange for click " + this.readyState + " " + this.status ;
			if (this.readyState == 4 && this.status == 200) {
				// Typical action to be performed when the document is ready:
			    var parms = JSON.parse(xhttp.responseText);
			    moveCoords = parms["move"];
			    flipList = parms["flips"];
			    colour = parms["colour"];
				document.getElementById("DebugText").innerHTML = "Board after move: " + serialBoardString;
				if (flipList.length > 0) {
					drawPiece(moveCoords[0], moveCoords[1], colour==nextMove);
					animateFlips(flipList, colour);
		  			move(moveCoords[0], moveCoords[1]);
		  			}
		  		else { // no valid move, pass
		  			changeNextMove();
		  		}
			}
  		};
		xhttp.send();
	}

	function move(x,y) {
		xhttp = new XMLHttpRequest();
			  url = "../move?" +
					 "x=" + x + "&" +
			  "y=" + y + "&" +
			  "newSquareState=" + nextMove + "&" +
			  "boardState=" + serialBoardString;

		xhttp.open("GET", url, true);
		xhttp.onreadystatechange =
		function() {
		  document.getElementById("DebugText").innerHTML = "onreadystatechange for click " + this.readyState + " " + this.status ;
		  if (this.readyState == 4 && this.status == 200) {
			  // Typical action to be performed when the document is ready:
			  serialBoardString = xhttp.responseText;
		  }

		  changeNextMove();
		};
		xhttp.send();
	}

	boardView.onclick = function clickBoard(e) {

	  // center in the square
	  x = Math.floor(e.clientX/window.squareSize);
	  y = Math.floor(e.clientY/window.squareSize);

	  document.getElementById("DebugText").innerHTML = "click " + x + " " + y;

	  xhttp = new XMLHttpRequest();
	  url = "../moveFlips?" +
			"x=" + x + "&" +
			"y=" + y + "&" +
			"newSquareState=" + nextMove + "&" +
			"boardState=" + serialBoardString;
	  xhttp.open("GET", url, true);

	  xhttp.onreadystatechange =
	  function() {
		  if (this.readyState == 4 && this.status == 200) {
			  var parms = JSON.parse(xhttp.responseText);
			  flipList = parms["flips"];
			  colour = parms["colour"];
			  document.getElementById("DebugText").innerHTML = "Flips response " + xhttp.responseText + " flipList " + flipList + " flipList length = " + flipList.length;

			  if (flipList.length > 0) {
				drawPiece(x, y, nextMove=="black");
				animateFlips(flipList, colour);
				move(x, y);
		  		window.setTimeout(counterMove, 2000);
			  }
		  }
	  }

	  xhttp.send();
	}

  </script>
</body>
</html>
